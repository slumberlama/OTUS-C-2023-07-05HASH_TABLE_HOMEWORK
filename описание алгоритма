Реализация хеш-таблицы с открытой адресацией
С открытой адресацией это значит, что если наша хеш-функция не совершенна и в результате работы с ней мы хотим использовать уже занятую ячейку, то нам придётся искать следующий свободный слот памяти и записать туда
Для создания хеш-функции нужно предположить, какое примерно количество разных слов в файле ожидается кодировка, файла, таблица Windows CP-1251 для нахождения суммы слов

т.е. у нас будет 3 колонки ID, слово, частота его встречаемости

в самой программе мы берём файл, считываем все слова в один большой массив и работаем с массивом или работаем как с одной большой строкой, но строки скорее всего будут заканчиваться
смотрим, сколько у нас слов это делаем с помощью определения количества пробелов

можем создать тупо столько ячеек, сколько слов в файле, чтобы точно хватило и коллизий не возникло, но ТО поиск по таблице будет занимать много времени, т.к. достаточно ячеек будут пустыми
чем больше массив, тем меньше коллизий, но и тем больше памяти выделяется

Допустим, у нас есть уже какая-нибудь хеш-функция и хеш-таблица
В командной строке мы должны получить слово – частота встречаемости, т.е. элемент массива встречаемости

Для хеш-функции нам нужно количество слов в файле. Есть 2 пути для вычисления этого: перевести в массив и посчитать количество слов в нём или сразу из файла прочитать, но, чтобы считывать потом слова легче сразу воспользоваться массивом.

С открытой адресацией – значит коллизии будут решаться с помощью открытой адресации, т.е. в том случае, если ячейка занята, записываем информацию в следующую свободную.
При этом вроде как есть возможность применить в таком случае другую хеш-функцию, запасную.

Простейшая хеш-функция для файла со словами:
Переводим символы в какую-нибудь кодировку с кириллицей, затем складываем каждое слово и находим остаток от деления на количество всех слов или размер файла.
Таблица 1 – Структура Ht_item  – Структура пары ключ значение в хеш-таблице
Символическое имя 
элемента структуры
Пояснение
Тип
Принимаемые значения
Key
Слово из файла, ключ 
unsigned char *
0…0xFF
Value
Частота встречаемости слова в файле, значение
unsigned int
0…0xFFFFFFFF
size_key
Количество символов в слове, размер ключа
unsigned int
0…0xFFFFFFFF

Таблица 2 - Структура HashTable – Структура пары ключ значение в хеш-таблице
Символическое имя 
элемента структуры
Пояснение
Тип
Принимаемые значения
items
Пара ключ-значение, слово- частота встречаемости 
Ht_item **
-
size
Размер хеш-таблицы
unsigned int
0…0xFFFFFFFF
count
Количество заполненных слов в таблице
unsigned int
0…0xFFFFFFFF

create_item («Создать пару ключ-значение»)
Параметры функции: 
Прототип функции
int is_space(unsigned char c)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
c
unsigned char
0…0xFF
Входной символ, над которым выполняется проверка: пробел это, или нет
-






Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

-
-
0 если результат сравнения ложь, 1 - результат сравнения истина
Описание алгоритма:
Проверяем входной символ, является он пробелом или нет путём сравнения с символом пробела.

is_it_space («Это пробел?»)
Параметры функции: 
Прототип функции
int is_it_space (unsigned char c)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
c
unsigned char
0…0xFF
Входной символ, над которым выполняется проверка: пробел это, или нет
-






Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

-
-
1 – пробел, 0 – другой символ
Описание алгоритма:
Проверяем входной символ, является он пробелом или нет путём сравнения с символом пробела.

isnt_space («Это не пробел?»)
Параметры функции
Прототип функции
int isnt_space(unsigned char c)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
c
unsigned char
0…0xFF
Входной символ
Входной символ, над которым выполняется проверка: пробел это, другой символ или нет






Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

-
-
0 – если пробел, 1 – другой символ
Описание алгоритма:
Проверяем входной символ, НЕ является ли он пробелом или нет путём сравнения 0 с результатом работы функции is_it_space (Это пробел?).

is_it_space_or_other_symbols («Это пробел или другой символ?»)
Параметры функции: 
Прототип функции
int is_it_space_or_other_symbols(unsigned char c)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
c
unsigned char
0…0xFF
Входной символ
Входной символ, над которым выполняется проверка: пробел это, или нет






Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

-
-
1 – буква, 0 – другой символ
Описание алгоритма:
Проверяем входной символ, является ли он пробелом или другим символом из таблицы ASCII. Под другими символами подразумеваются символы в ASCII, которые не входят в слово. 

is_not_space_or_other_symbols («Это не пробел или другой символ?»)
Параметры функции: 
Прототип функции
int is_not_space_or_other_symbols(unsigned char c)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
c
unsigned char
0…0xFF
Входной символ
Входной символ, над которым выполняется проверка: пробел это, или нет






Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

-
-
1 – буква, 0 – другой символ
Описание алгоритма:
Проверяем входной символ, НЕ является ли он пробелом или другим символом из таблицы ASCII. Под другими символами подразумеваются символы в ASCII, которые не входят в слово. 

count_start_if («Счёт начинается, если»)
Параметры функции: 
Прототип функции
int count_start_if(char * str, int (*pred)(char))



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
str
char
0…0xFF
Входная строка
-

вход
int (*pred)(char)










Локальные переменные:
вход/выход
count
int
-2 147 483 647 …+2 147 483 647
Счётчик
Счётчик элементов
Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

Счётчик
int
-2 147 483 647 … +2 147 483 647
Описание алгоритма:
    1. Объявляем и инициализируем нулём локальную переменную count, которая будет отвечать за счётчик.
    2. Организуем цикл while с условием пока строка не закончится, т.е. указатель на элемент не равен 0:
while(*str!=0)
        2.1 В цикле проверяем условие: ЕСЛИ pred от элемента строки не 0:
if(pred(*str))
            2.1.1 Инкрементируем счётчик:
count++
            2.1.2 Переходим к следующему элементу массива:
str++
        2.2 ИНАЧЕ:
            2.1.1 Выходим из цикла:
break
    3. Возвращаем счётчик элементов

count_words(«Подсчёт слов»)
Параметры функции: 
Прототип функции
int count_words(char * str)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
str
char
0…0xFF
Входная строка
-






Локальные переменные:
вход/выход
length
int
-2 147 483 647 …+2 147 483 647
Длина строки
Длина строки

вход/выход
count
int
-2 147 483 647 …+2 147 483 647
Счётчик элементов
Счётчик элементов

вход/выход
i
int
-2 147 483 647 …+2 147 483 647
Счётчик цикла
Счётчик цикла

вход/выход
spaces_count
int
-2 147 483 647 …+2 147 483 647
Счётчик пробелов
Счётчик пробелов

вход/выход
word_length
int
-2 147 483 647 …+2 147 483 647
Длина слова
Длина слова
Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

Счётчик
int
-2 147 483 647 … +2 147 483 647
Описание алгоритма:
    1. Объявляем и инициализируем локальную переменную length значением длины строки str с помощью функции strlen.
int length = strlen(str)
    2. Объявляем и инициализируем нулём локальные переменные count и i.
    3. Организуем бесконечный цикл while:
while(1)
        2.1 В цикле объявляем и инициализируем локальную переменную spaces_count с помощью функции «Счёт начинается, если» (count_start_if) с параметрами &str[i] – адрес i-ого элемента строки str, функция «Это пробел» (is_space).
        2.2 К счётчику цикла while i прибавляем значение переменной spaces_count.
i += spaces_count
        2.3 Проверяем условие: ЕСЛИ счётчик цикла while i больше или равен длине строки length
if(i >= length)
            2.3.1 Выход из цикла while
break
        2.4 В цикле объявляем и инициализируем локальную переменную word_length с помощью функции «Счёт начинается, если» (count_start_if) с параметрами &str[i] – адрес i-ого элемента строки str, функция «Это не пробел» (is_not_space).
        2.5 Проверяем условие: ЕСЛИ длина слова word_length больше 0:
if(word_length > 0)
            2.3.1 Инкрементируем счётчик слов count.
count++
        2.6 К счётчику цикла while i прибавляем значение переменной word_length.
i += word_length
        2.7 Проверяем условие: ЕСЛИ счётчик цикла while i больше или равен длине строки length
if(i >= length)
            2.3.1 Выход из цикла while
break
    4. Возвращаем счётчик элементов count

hash_function (unsigned char * str)
Параметры функции: 
Прототип функции
unsigned long hash_function(unsigned char * str)



Параметры:
Вход/Выход/Элемент с памятью
Символическое имя
Тип
Допустимые значения
Обозначение в алгоритме
Назначение

вход
str
unsigned char *
0…0xFF
Ключ
Слово в таблице из файла
Глобальные переменные:
вход
count_word
unsigned long
многа
Количество слов в файле
Количество слов в файле
Локальные переменные:
вход/выход
i
unsigned long
многа
Сумма
Сумма элементов в строке

вход/выход
j
int
-2 147 483 647 …+2 147 483 647
Счётчик цикла for
Счётчик цикла
Возвращаемое значение
Обозначение в алгоритме
Тип
Возможные значения

Значение хеш-функции
unsigned long
многа
Описание алгоритма:
    1. Чтобы не записывался мусор в сумму, инициализируем 0 переменную i, к-я отвечает за сумму элементов в строке:
unsigned long i = 0;
    2. Организуем цикл for, используя счётчик j, условие выхода элемент массива равен 0, каждый раз увеличиваем j:
for(int j = 0; str[j]; j++)
        2.1 В цикле организуем сложение элементов массива и запись суммы на каждом шаге в переменную i:
i += str[j];
    3. Возвращаемое значение сумма i делённая на количество элементов в таблице, т.е. на глобальную переменную count_word.


main(«Головная программа»)




